import google.generativeai as genai
import os
from typing import Dict, Any, List, Optional
from services.lastfm_service import LastFMService
from services.navidrome_service import NavidromeService
from services.listenbrainz_service import ListenBrainzService
from services.conversation_manager import ConversationManager
from services.system_prompts import SystemPrompts

class MusicAgentService:
    """
    Agente musical inteligente que combina todas las fuentes de datos
    para responder consultas conversacionales sobre m√∫sica
    """
    
    def __init__(self):
        genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
        self.model = genai.GenerativeModel('gemini-2.0-flash-exp')
        
        # Gestor de conversaciones
        self.conversation_manager = ConversationManager()
        
        # Inicializar servicios disponibles
        self.lastfm = None
        if os.getenv("LASTFM_API_KEY") and os.getenv("LASTFM_USERNAME"):
            try:
                self.lastfm = LastFMService()
                print("‚úÖ Agente musical: Last.fm habilitado")
            except Exception as e:
                print(f"‚ö†Ô∏è Agente musical: Error inicializando Last.fm: {e}")
        
        self.navidrome = NavidromeService()
        
        self.listenbrainz = None
        if os.getenv("LISTENBRAINZ_USERNAME"):
            try:
                self.listenbrainz = ListenBrainzService()
                print("‚úÖ Agente musical: ListenBrainz habilitado")
            except Exception as e:
                print(f"‚ö†Ô∏è Agente musical: Error inicializando ListenBrainz: {e}")
        
        # Determinar servicio de scrobbling principal
        self.music_service = self.lastfm or self.listenbrainz
        self.music_service_name = "Last.fm" if self.lastfm else "ListenBrainz" if self.listenbrainz else None
    
    async def query(
        self, 
        user_question: str, 
        user_id: int,
        context: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Procesar consulta del usuario usando todas las fuentes disponibles
        CON SOPORTE CONVERSACIONAL
        
        Args:
            user_question: Pregunta o consulta del usuario
            user_id: ID del usuario para mantener contexto conversacional
            context: Contexto adicional (opcional)
            
        Returns:
            Diccionario con la respuesta y datos utilizados
            
        Ejemplos:
            - "¬øQu√© √°lbumes de Pink Floyd tengo en mi biblioteca?"
            - "Dame informaci√≥n sobre el √∫ltimo artista que escuch√©"
            - "¬øCu√°ntas veces he escuchado a Queen?"
            - "Dime √°lbumes similares a The Dark Side of the Moon"
            - "Ponme algo parecido" (usa contexto de conversaci√≥n)
        """
        
        print(f"ü§ñ Agente musical procesando: {user_question}")
        
        # Obtener sesi√≥n conversacional del usuario
        session = self.conversation_manager.get_session(user_id)
        session.add_message("user", user_question)
        
        # 1. Recopilar datos de todas las fuentes
        data_context = await self._gather_all_data(user_question)
        
        # 2. Obtener estad√≠sticas del usuario para personalizaci√≥n
        user_stats = {}
        if self.music_service:
            try:
                top_artists_data = await self.music_service.get_top_artists(limit=5)
                user_stats['top_artists'] = [a.name for a in top_artists_data]
                
                recent_tracks = await self.music_service.get_recent_tracks(limit=1)
                if recent_tracks:
                    user_stats['last_track'] = f"{recent_tracks[0].artist} - {recent_tracks[0].name}"
            except Exception as e:
                print(f"‚ö†Ô∏è Error obteniendo stats para contexto: {e}")
        
        # 3. Construir prompt inteligente usando SystemPrompts
        conversation_context = session.get_context_for_ai()
        system_prompt = SystemPrompts.get_music_assistant_prompt(
            user_stats=user_stats,
            conversation_context=conversation_context
        )
        
        # 4. Agregar datos espec√≠ficos de la query
        ai_prompt = f"""{system_prompt}

=== CONSULTA ACTUAL ===
{user_question}

=== DATOS DISPONIBLES ===
{self._format_context_for_ai(data_context)}

REGLAS CR√çTICAS:
1. SIEMPRE consulta PRIMERO la biblioteca (üìö) para ver qu√© tiene el usuario
2. LUEGO complementa con Last.fm (üåç) para recomendaciones y descubrimientos
3. Si preguntan "mejor disco/√°lbum de X":
   a) Verifica QU√â TIENE en biblioteca de ese artista
   b) Combina con recomendaciones de Last.fm
   c) Responde: "En tu biblioteca tienes X, Y, Z. Seg√∫n Last.fm, el mejor es..."
4. Si preguntan "qu√© tengo de X" ‚Üí USA SOLO BIBLIOTECA
5. NUNCA digas "no tienes nada" sin VERIFICAR primero en los datos de biblioteca
6. VERIFICA coincidencia exacta de artistas - no mezcles artistas diferentes
7. S√© PROACTIVO: combina siempre biblioteca + descubrimiento

IMPORTANTE - Diferentes tipos de peticiones:

1. "¬øQu√© √°lbumes TENGO de [artista]?"
   ‚Üí Busca SOLO en BIBLIOTECA
   ‚Üí Si no tiene ‚Üí "No tienes √°lbumes de [artista] en tu biblioteca"

2. "Recomi√©ndame un disco DE [artista]"
   ‚Üí Busca en BIBLIOTECA primero
   ‚Üí Si no tiene ‚Üí Busca en LAST.FM y recomienda
   ‚Üí Ejemplo: "No tienes de [artista] en biblioteca, pero en Last.fm su mejor √°lbum es X"

3. "Recomi√©ndame un disco" (sin artista espec√≠fico)
   ‚Üí USA BIBLIOTECA + LAST.FM
   ‚Üí Combina: algo de su biblioteca + descubrimientos nuevos
   ‚Üí Ejemplo: "De tu biblioteca: X. Tambi√©n te gustar√° Y (nuevo en Last.fm)"

4. "Recomi√©ndame algo nuevo / que no tenga"
   ‚Üí USA PRINCIPALMENTE LAST.FM
   ‚Üí Recomienda m√∫sica que NO est√° en biblioteca
   ‚Üí Basado en sus gustos pero nuevo contenido

IMPORTANTE - "Playlist con m√∫sica DE [artistas]":
- Si piden "playlist de/con [lista de artistas]", busca canciones de ESOS ARTISTAS ESPEC√çFICOS
- Ejemplo: "m√∫sica de mujeres, vera fauna y cala vento" ‚Üí busca canciones de esos 3 artistas
- VERIFICA que cada canci√≥n sea del artista correcto
- Si NO tienes algunos artistas, menciona cu√°les S√ç tienes y cu√°les NO

FORMATO DE RESPUESTA:
- Si hay √°lbumes en biblioteca DEL ARTISTA CORRECTO ‚Üí Lista y recomienda
- Si hay artistas en biblioteca ‚Üí Lista los artistas directamente
- Si piden "recomi√©ndame √°lbum de X" y NO tienes de X ‚Üí "No tienes √°lbumes de X en tu biblioteca"
- Si piden "playlist con X, Y, Z" ‚Üí Lista qu√© artistas S√ç tienes y cu√°les NO
- NUNCA inventes √°lbumes o artistas que no aparecen en los datos
- Usa emojis: üìÄ para √°lbumes, üé§ para artistas, üéµ para canciones

Responde ahora de forma natural y conversacional:"""
        
        # 5. Generar respuesta con IA
        try:
            response = self.model.generate_content(ai_prompt)
            answer = response.text.strip()
            
            print(f"‚úÖ Agente musical: Respuesta generada ({len(answer)} caracteres)")
            
            # Guardar respuesta en historial de conversaci√≥n
            session.add_message("assistant", answer)
            
            return {
                "answer": answer,
                "data_used": data_context,
                "links": self._extract_lastfm_links(data_context),
                "success": True,
                "session_id": user_id
            }
        
        except Exception as e:
            print(f"‚ùå Error generando respuesta del agente: {e}")
            return {
                "answer": f"‚ùå Error procesando tu consulta: {str(e)}",
                "data_used": data_context,
                "links": [],
                "success": False
            }
    
    async def _gather_all_data(self, query: str) -> Dict[str, Any]:
        """Recopilar datos de todas las fuentes disponibles
        
        Args:
            query: Consulta del usuario para determinar qu√© datos recopilar
            
        Returns:
            Diccionario con todos los datos relevantes
        """
        data = {
            "library": {},
            "listening_history": {},
            "search_results": {},
            "similar_content": [],
            "new_discoveries": []  # NUEVO: Para m√∫sica que no est√° en biblioteca
        }
        
        # Detectar palabras clave para optimizar b√∫squedas
        query_lower = query.lower()
        
        # Detectar menciones de artistas/√°lbumes/discos (buscar en biblioteca)
        # MEJORADO: Tambi√©n buscar cuando preguntan por "mejor disco de", "√°lbum de", etc.
        needs_library_search = any(word in query_lower for word in [
            "tengo", "teengo", "biblioteca", "colecci√≥n", "poseo", 
            "√°lbum", "album", "disco", "√°lbumes", "albums", "discos",
            "mejor disco de", "mejor √°lbum de", "disco de", "√°lbum de",
            "discograf√≠a", "m√∫sica de", "canciones de", "temas de"
        ])
        
        needs_listening_history = any(word in query_lower for word in [
            "escuch√©", "escuchado", "√∫ltima", "reciente", "top", "favorito", "estad√≠stica", "√∫ltimos"
        ])
        
        # NUEVO: Detectar cuando el usuario pide descubrir m√∫sica nueva
        needs_new_music = any(word in query_lower for word in [
            "nuevo", "nueva", "nuevos", "nuevas", "no tenga", "descubrir", 
            "recomienda", "recomi√©ndame", "sugerencia", "otra cosa", "mejor"
        ])
        
        # Extraer t√©rmino de b√∫squeda real (eliminar palabras comunes)
        search_term = self._extract_search_term(query) if needs_library_search else query
        
        # Datos de biblioteca (Navidrome)
        if needs_library_search and search_term:
            try:
                print(f"üîç Buscando en biblioteca: '{search_term}' (query original: '{query}')")
                # B√∫squeda en biblioteca con el t√©rmino extra√≠do
                search_results = await self.navidrome.search(search_term, limit=20)
                
                # FILTRAR resultados para mantener solo los que realmente coincidan con el artista
                filtered_results = self._filter_relevant_results(search_results, search_term)
                
                data["library"]["search_results"] = filtered_results
                data["library"]["search_term"] = search_term
                
                # Si la b√∫squeda devuelve resultados, agregar m√°s contexto
                if any(filtered_results.values()):
                    data["library"]["has_content"] = True
                    print(f"‚úÖ Encontrado en biblioteca (despu√©s de filtrar): {len(filtered_results.get('tracks', []))} tracks, {len(filtered_results.get('albums', []))} √°lbumes, {len(filtered_results.get('artists', []))} artistas")
                else:
                    data["library"]["has_content"] = False
                    print(f"‚ö†Ô∏è No se encontraron resultados relevantes en biblioteca para '{search_term}'")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è Error obteniendo datos de Navidrome: {e}")
                data["library"]["error"] = str(e)
        
        # Datos de escucha (Last.fm o ListenBrainz)
        if self.music_service and needs_listening_history:
            try:
                print(f"üìä Obteniendo historial de escucha de {self.music_service_name}")
                
                # Obtener datos b√°sicos
                data["listening_history"]["recent_tracks"] = await self.music_service.get_recent_tracks(limit=20)
                data["listening_history"]["top_artists"] = await self.music_service.get_top_artists(limit=10)
                
                # Si preguntan por tracks espec√≠ficos
                if "canci√≥n" in query_lower or "track" in query_lower or "tema" in query_lower:
                    data["listening_history"]["top_tracks"] = await self.music_service.get_top_tracks(limit=10)
                
                # Si preguntan por estad√≠sticas
                if "estad√≠stica" in query_lower or "stats" in query_lower or "cu√°nto" in query_lower:
                    if hasattr(self.music_service, 'get_user_stats'):
                        data["listening_history"]["stats"] = await self.music_service.get_user_stats()
                
            except Exception as e:
                print(f"‚ö†Ô∏è Error obteniendo historial de escucha: {e}")
                data["listening_history"]["error"] = str(e)
        
        # B√∫squeda de contenido similar (usando Last.fm)
        if self.lastfm and ("similar" in query_lower or "parecido" in query_lower or "como" in query_lower):
            try:
                print(f"üîç Buscando contenido similar")
                # Extraer nombre de artista/√°lbum de la query
                words = query.split()
                for i, word in enumerate(words):
                    if word.lower() in ["similar", "parecido", "como"] and i + 1 < len(words):
                        potential_artist = " ".join(words[i+1:])
                        similar_artists = await self.lastfm.get_similar_artists(potential_artist, limit=5)
                        if similar_artists:
                            data["similar_content"] = similar_artists
                        break
            except Exception as e:
                print(f"‚ö†Ô∏è Error buscando contenido similar: {e}")
        
        # NUEVO: Buscar informaci√≥n de Last.fm sobre artistas espec√≠ficos cuando preguntan por "mejor disco/√°lbum"
        if self.lastfm and needs_library_search and search_term and any(word in query_lower for word in ["mejor", "recomend"]):
            try:
                print(f"üåç Buscando informaci√≥n de Last.fm sobre '{search_term}'...")
                # Obtener top √°lbumes del artista desde Last.fm
                top_albums = await self.lastfm.get_artist_top_albums(search_term, limit=10)
                if top_albums:
                    data["lastfm_artist_info"] = {
                        "artist": search_term,
                        "top_albums": top_albums
                    }
                    print(f"‚úÖ Encontrados {len(top_albums)} √°lbumes de '{search_term}' en Last.fm")
            except Exception as e:
                print(f"‚ö†Ô∏è Error obteniendo info de Last.fm para '{search_term}': {e}")
        
        # NUEVO: Buscar m√∫sica nueva activamente cuando lo pidan
        if needs_new_music and self.music_service:
            try:
                print(f"üåç Buscando m√∫sica NUEVA basada en gustos del usuario...")
                
                # Obtener top artistas del usuario
                top_artists = await self.music_service.get_top_artists(limit=5)
                
                if top_artists and self.lastfm:
                    # Buscar artistas similares a sus favoritos
                    new_discoveries = []
                    for top_artist in top_artists[:3]:  # Solo los top 3
                        similar = await self.lastfm.get_similar_artists(top_artist.name, limit=3)
                        for artist in similar:
                            # Agregar solo si no est√° duplicado
                            if artist.name not in [d.get('artist') for d in new_discoveries]:
                                # Obtener el √°lbum top del artista para dar recomendaci√≥n concreta
                                top_albums = await self.lastfm.get_artist_top_albums(artist.name, limit=1)
                                
                                discovery = {
                                    'artist': artist.name,
                                    'url': artist.url if hasattr(artist, 'url') else None,
                                    'top_album': top_albums[0].get('name') if top_albums else None,
                                    'album_url': top_albums[0].get('url') if top_albums else None,
                                    'similar_to': top_artist.name  # Para contexto
                                }
                                new_discoveries.append(discovery)
                        
                        # Limitar a 8 descubrimientos total
                        if len(new_discoveries) >= 8:
                            break
                    
                    if new_discoveries:
                        data["new_discoveries"] = new_discoveries[:8]
                        print(f"‚úÖ Encontrados {len(data['new_discoveries'])} descubrimientos con √°lbums espec√≠ficos")
                
            except Exception as e:
                print(f"‚ö†Ô∏è Error buscando m√∫sica nueva: {e}")
        
        return data
    
    def _format_context_for_ai(self, data: Dict[str, Any]) -> str:
        """Formatear contexto para que la IA lo entienda
        
        Args:
            data: Diccionario con todos los datos recopilados
            
        Returns:
            String formateado con toda la informaci√≥n para la IA
        """
        formatted = ""
        
        # SIEMPRE mostrar primero la biblioteca (si hay b√∫squeda)
        if data.get("library"):
            lib = data["library"]
            search_term = lib.get("search_term", "")
            
            if lib.get("search_results"):
                results = lib["search_results"]
                
                # Priorizar √°lbumes si existen
                if results.get("albums"):
                    formatted += f"\nüìö === BIBLIOTECA LOCAL === \n"
                    formatted += f"üìÄ √ÅLBUMES ENCONTRADOS PARA '{search_term.upper()}' ({len(results['albums'])}):\n"
                    formatted += f"‚ö†Ô∏è IMPORTANTE: Verifica que el ARTISTA coincida con lo solicitado\n\n"
                    for i, album in enumerate(results["albums"][:15], 1):
                        formatted += f"  {i}. ARTISTA: {album.artist} | √ÅLBUM: {album.name}"
                        if album.year:
                            formatted += f" ({album.year})"
                        if album.track_count:
                            formatted += f" - {album.track_count} canciones"
                        formatted += "\n"
                    formatted += "\n"
                
                # Luego artistas
                if results.get("artists"):
                    if not results.get("albums"):  # Solo mostrar si no hay √°lbumes
                        formatted += f"\nüìö === BIBLIOTECA LOCAL === \n"
                    formatted += f"üé§ ARTISTAS ENCONTRADOS EN BIBLIOTECA ({len(results['artists'])}):\n"
                    formatted += f"‚ö†Ô∏è Verifica que el nombre coincida con lo que pidi√≥ el usuario\n\n"
                    for i, artist in enumerate(results["artists"][:10], 1):
                        formatted += f"  {i}. ARTISTA: {artist.name}"
                        if artist.album_count:
                            formatted += f" | {artist.album_count} √°lbumes disponibles"
                        formatted += "\n"
                    formatted += "\n"
                
                # Luego canciones
                if results.get("tracks"):
                    if not results.get("albums") and not results.get("artists"):
                        formatted += f"\nüìö === BIBLIOTECA LOCAL === \n"
                    formatted += f"üéµ CANCIONES ENCONTRADAS EN BIBLIOTECA ({len(results['tracks'])}):\n"
                    formatted += f"‚ö†Ô∏è Verifica que el ARTISTA coincida\n\n"
                    for i, track in enumerate(results["tracks"][:10], 1):
                        formatted += f"  {i}. ARTISTA: {track.artist} | CANCI√ìN: {track.title}"
                        if track.album:
                            formatted += f" | √ÅLBUM: {track.album}"
                        if track.year:
                            formatted += f" [{track.year}]"
                        formatted += "\n"
                    formatted += "\n"
            
            # Si no se encontr√≥ nada, indicarlo claramente
            if lib.get("has_content") == False:
                formatted += f"\nüìö === BIBLIOTECA LOCAL === \n"
                formatted += f"‚ö†Ô∏è NO TIENES '{search_term.upper()}' EN TU BIBLIOTECA\n\n"
        
        # Historial de escucha (Last.fm o ListenBrainz) - SOLO SI ES RELEVANTE
        if data.get("listening_history"):
            hist = data["listening_history"]
            
            # Solo mostrar estad√≠sticas de Last.fm si NO hay datos de biblioteca
            # o si espec√≠ficamente pidieron estad√≠sticas
            if hist.get("stats"):
                stats = hist["stats"]
                formatted += f"\nüìä === ESTAD√çSTICAS DE LAST.FM (NO ES TU BIBLIOTECA) ===\n"
                formatted += f"  ‚Ä¢ Total de escuchas: {stats.get('total_listens', 'N/A')}\n"
                formatted += f"  ‚Ä¢ Artistas √∫nicos: {stats.get('total_artists', 'N/A')}\n"
                formatted += f"  ‚Ä¢ √Ålbumes √∫nicos: {stats.get('total_albums', 'N/A')}\n"
                formatted += f"  ‚Ä¢ Canciones √∫nicas: {stats.get('total_tracks', 'N/A')}\n\n"
            
            if hist.get("top_artists"):
                formatted += f"\nüèÜ TUS TOP ARTISTAS M√ÅS ESCUCHADOS (Last.fm):\n"
                for i, artist in enumerate(hist["top_artists"][:5], 1):  # Reducido a 5
                    formatted += f"  {i}. {artist.name}"
                    if artist.playcount:
                        formatted += f" ({artist.playcount} escuchas)"
                    formatted += "\n"
        
        # Informaci√≥n de Last.fm sobre artista espec√≠fico
        if data.get("lastfm_artist_info"):
            info = data["lastfm_artist_info"]
            formatted += f"\nüåç === INFORMACI√ìN DE LAST.FM: {info['artist'].upper()} ===\n"
            formatted += f"üìä TOP √ÅLBUMES M√ÅS POPULARES (seg√∫n Last.fm):\n\n"
            for i, album in enumerate(info["top_albums"][:10], 1):
                # Puede ser dict o objeto
                if isinstance(album, dict):
                    album_name = album.get('name', 'Unknown')
                    playcount = album.get('playcount', 0)
                    url = album.get('url', '')
                else:
                    album_name = getattr(album, 'name', 'Unknown')
                    playcount = getattr(album, 'playcount', 0)
                    url = getattr(album, 'url', '')
                
                formatted += f"  {i}. {album_name}"
                if playcount:
                    formatted += f" - {playcount:,} escuchas globales"
                if url:
                    formatted += f" | {url}"
                formatted += "\n"
            formatted += "\nüí° IMPORTANTE: Usa esta info para recomendar el mejor √°lbum\n"
            formatted += f"üí° Combina lo que tiene en biblioteca + popularidad en Last.fm\n\n"
        
        # Contenido similar
        if data.get("similar_content"):
            formatted += f"\nüîó ARTISTAS SIMILARES:\n"
            for i, artist in enumerate(data["similar_content"][:5], 1):
                url_info = f" - {artist.url}" if hasattr(artist, 'url') and artist.url else ""
                formatted += f"  {i}. {artist.name}{url_info}\n"
        
        # NUEVO: Descubrimientos (m√∫sica que NO est√° en biblioteca pero puede recomendar)
        if data.get("new_discoveries"):
            formatted += f"\nüåç === M√öSICA NUEVA PARA DESCUBRIR (de Last.fm) ===\n"
            formatted += f"üìå IMPORTANTE: Estos NO est√°n en tu biblioteca pero PUEDES recomendarlos\n"
            formatted += f"üéØ Basado en tus gustos, te pueden gustar:\n\n"
            
            for i, discovery in enumerate(data["new_discoveries"][:8], 1):
                # Puede ser dict (nuevo formato) o objeto (formato antiguo)
                if isinstance(discovery, dict):
                    artist = discovery.get('artist', 'Unknown')
                    album = discovery.get('top_album')
                    similar_to = discovery.get('similar_to', '')
                    url = discovery.get('url', '')
                    
                    formatted += f"  {i}. **{artist}**"
                    if album:
                        formatted += f" - √Ålbum recomendado: **{album}**"
                    if similar_to:
                        formatted += f" (similar a {similar_to})"
                    if url:
                        formatted += f" - {url}"
                    formatted += "\n"
                else:
                    # Formato antiguo (compatibilidad)
                    formatted += f"  {i}. {discovery.name}"
                    if hasattr(discovery, 'url') and discovery.url:
                        formatted += f" - {discovery.url}"
                    formatted += "\n"
            
            formatted += "\nüí° Recomienda estos √°lbumes/artistas libremente - son descubrimientos basados en sus gustos\n"
        
        # Si no hay datos
        if not formatted:
            formatted = "\n‚ö†Ô∏è No hay datos disponibles para responder esta consulta.\n"
        
        return formatted
    
    def _extract_lastfm_links(self, data: Dict[str, Any]) -> List[str]:
        """Extraer todos los enlaces de Last.fm del contexto
        
        Args:
            data: Diccionario con todos los datos
            
        Returns:
            Lista de URLs √∫nicas de Last.fm
        """
        links = []
        
        # Enlaces del historial de escucha
        if hist := data.get("listening_history"):
            # De tracks recientes
            for track in hist.get("recent_tracks", []):
                if hasattr(track, 'url') and track.url:
                    links.append(track.url)
            
            # De top artistas
            for artist in hist.get("top_artists", []):
                if hasattr(artist, 'url') and artist.url:
                    links.append(artist.url)
            
            # De top tracks
            for track in hist.get("top_tracks", []):
                if hasattr(track, 'url') and track.url:
                    links.append(track.url)
        
        # Enlaces de contenido similar
        for item in data.get("similar_content", []):
            if hasattr(item, 'url') and item.url:
                links.append(item.url)
        
        # Eliminar duplicados manteniendo el orden
        seen = set()
        unique_links = []
        for link in links:
            if link not in seen:
                seen.add(link)
                unique_links.append(link)
        
        return unique_links
    
    async def get_artist_info(self, artist_name: str) -> Dict[str, Any]:
        """Obtener informaci√≥n completa sobre un artista
        
        Args:
            artist_name: Nombre del artista
            
        Returns:
            Diccionario con informaci√≥n del artista
        """
        info = {
            "name": artist_name,
            "in_library": False,
            "listening_stats": {},
            "similar_artists": [],
            "top_albums": [],
            "top_tracks": []
        }
        
        # Buscar en biblioteca
        try:
            library_results = await self.navidrome.search(artist_name, limit=5)
            if library_results.get("artists"):
                info["in_library"] = True
                info["library_albums"] = library_results.get("albums", [])
                info["library_tracks"] = library_results.get("tracks", [])
        except Exception as e:
            print(f"Error buscando en biblioteca: {e}")
        
        # Informaci√≥n de Last.fm
        if self.lastfm:
            try:
                # Artistas similares
                info["similar_artists"] = await self.lastfm.get_similar_artists(artist_name, limit=5)
                
                # Top √°lbumes
                info["top_albums"] = await self.lastfm.get_artist_top_albums(artist_name, limit=5)
                
                # Top tracks
                info["top_tracks"] = await self.lastfm.get_artist_top_tracks(artist_name, limit=5)
            except Exception as e:
                print(f"Error obteniendo info de Last.fm: {e}")
        
        return info
    
    def _filter_relevant_results(self, results: Dict[str, List], search_term: str) -> Dict[str, List]:
        """Filtrar resultados de b√∫squeda para mantener solo los relevantes
        
        Elimina resultados que claramente NO coincidan con el artista buscado.
        Ej: Si buscas "Tobog√°n Andaluz", elimina "El Perro Andaluz"
        
        Args:
            results: Resultados de b√∫squeda de Navidrome
            search_term: T√©rmino que el usuario busc√≥
            
        Returns:
            Resultados filtrados
        """
        from difflib import SequenceMatcher
        
        def similarity_ratio(a: str, b: str) -> float:
            """Calcular similitud entre dos strings"""
            return SequenceMatcher(None, a.lower(), b.lower()).ratio()
        
        # Umbral de similitud (0.6 = 60% similar)
        SIMILARITY_THRESHOLD = 0.6
        
        filtered = {
            "tracks": [],
            "albums": [],
            "artists": []
        }
        
        search_lower = search_term.lower()
        
        # Filtrar √°lbumes
        for album in results.get("albums", []):
            artist_similarity = similarity_ratio(album.artist, search_term)
            album_similarity = similarity_ratio(album.name, search_term)
            artist_lower = album.artist.lower()
            
            # MEJORADO: Mantener si:
            # 1. El t√©rmino de b√∫squeda est√° CONTENIDO en el nombre del artista
            # 2. El artista es similar al t√©rmino de b√∫squeda (60%+)
            # 3. El √°lbum contiene el t√©rmino de b√∫squeda
            if (search_lower in artist_lower or 
                artist_lower.startswith(search_lower) or
                artist_similarity >= SIMILARITY_THRESHOLD or 
                search_lower in album.name.lower()):
                filtered["albums"].append(album)
                print(f"   ‚úì √Ålbum mantenido: {album.artist} - {album.name} (similitud: {artist_similarity:.2f})")
            else:
                print(f"   ‚úó √Ålbum filtrado: {album.artist} - {album.name} (similitud: {artist_similarity:.2f})")
        
        # Filtrar artistas
        for artist in results.get("artists", []):
            artist_similarity = similarity_ratio(artist.name, search_term)
            artist_lower = artist.name.lower()
            
            # MEJORADO: Mantener si el t√©rmino est√° contenido o el nombre comienza con √©l
            if (search_lower in artist_lower or 
                artist_lower.startswith(search_lower) or
                artist_similarity >= SIMILARITY_THRESHOLD):
                filtered["artists"].append(artist)
                print(f"   ‚úì Artista mantenido: {artist.name} (similitud: {artist_similarity:.2f})")
            else:
                print(f"   ‚úó Artista filtrado: {artist.name} (similitud: {artist_similarity:.2f})")
        
        # Filtrar canciones
        for track in results.get("tracks", []):
            artist_similarity = similarity_ratio(track.artist, search_term)
            artist_lower = track.artist.lower()
            
            # MEJORADO: Mantener si el t√©rmino est√° contenido en el artista
            if (search_lower in artist_lower or 
                artist_lower.startswith(search_lower) or
                artist_similarity >= SIMILARITY_THRESHOLD):
                filtered["tracks"].append(track)
            else:
                print(f"   ‚úó Canci√≥n filtrada: {track.artist} - {track.title}")
        
        return filtered
    
    def _extract_search_term(self, query: str) -> str:
        """Extraer el t√©rmino de b√∫squeda real de una consulta en lenguaje natural
        
        Ejemplos:
            "¬øQu√© √°lbumes de Pink Floyd tengo?" -> "Pink Floyd"
            "Busca Queen en mi biblioteca" -> "Queen"
            "Tengo discos de The Beatles?" -> "The Beatles"
        
        Args:
            query: Consulta en lenguaje natural
            
        Returns:
            T√©rmino de b√∫squeda extra√≠do
        """
        import re
        
        # Palabras a ignorar (stop words en espa√±ol)
        stop_words = {
            'qu√©', 'que', 'cual', 'cu√°l', 'cuales', 'cu√°les', 'c√≥mo', 'como',
            'de', 'del', 'la', 'el', 'los', 'las', 'un', 'una', 'unos', 'unas',
            'tengo', 'tienes', 'tiene', 'en', 'mi', 'tu', 'su',
            'biblioteca', 'colecci√≥n', '√°lbum', '√°lbumes', 'album', 'albums',
            'disco', 'discos', 'canci√≥n', 'canciones', 'cancion',
            'artista', 'artistas', 'por', 'para', 'con', 'sin',
            'hay', 'est√°', 'esta', 'est√°n', 'estan', 'son', 'es',
            'busca', 'buscar', 'encuentra', 'encontrar', 'dame', 'dime',
            'muestra', 'mostrar', 'ver', 'a', 'e', 'i', 'o', 'u', 'y',
            'mejor', 'peor'
        }
        
        # ESTRATEGIA 1: Buscar patr√≥n "de [artista]" (M√ÅS CONFIABLE)
        # Esta estrategia debe ir PRIMERA porque es m√°s espec√≠fica y evita confusiones
        # Ejemplo: "Cual es el mejor disco de el mat√≥?" ‚Üí extrae "el mat√≥"
        de_patterns = [
            # Patr√≥n espec√≠fico para "mejor/peor disco/√°lbum de X"
            r'(?:mejor|peor)\s+(?:disco|√°lbum|album)\s+de\s+(.+?)(?:\?|$)',
            # Patr√≥n para "disco/√°lbum de X"
            r'(?:disco|√°lbum|album)\s+de\s+(.+?)(?:\?|$)',
            # Patr√≥n general "de X" (cuando no hay palabras anteriores conflictivas)
            r'\bde\s+([a-z√°√©√≠√≥√∫√±][a-z√°√©√≠√≥√∫√±\s]+?)(?:\?|$)'
        ]
        
        for de_pattern in de_patterns:
            de_match = re.search(de_pattern, query, re.IGNORECASE)
            if de_match:
                result = de_match.group(1).strip()
                # Limpiar palabras comunes al final
                result = re.sub(r'\s+(tengo|teengo|en|mi|tu|biblioteca|es|son)$', '', result, flags=re.IGNORECASE)
                # Limpiar interrogantes y espacios
                result = result.rstrip('? ').strip()
                # Verificar que no sea solo stop words
                words = result.lower().split()
                if result and len(result) > 2 and not all(w in stop_words for w in words):
                    print(f"üîç T√©rmino extra√≠do (patr√≥n 'de'): '{result}'")
                    return result
        
        # ESTRATEGIA 2: Buscar nombres propios (palabras con may√∫sculas)
        # Pero filtrar palabras interrogativas comunes que podr√≠an estar al inicio
        capitalized_pattern = r'\b([A-Z][a-z√°√©√≠√≥√∫√±]+(?:\s+[A-Z][a-z√°√©√≠√≥√∫√±]+)*)\b'
        cap_matches = re.findall(capitalized_pattern, query)
        
        if cap_matches:
            # Filtrar palabras interrogativas aunque tengan may√∫scula
            question_words = {'cual', 'cu√°l', 'qu√©', 'que', 'qui√©n', 'quien', 'c√≥mo', 'como', 'd√≥nde', 'donde', 'cu√°ndo', 'cuando'}
            filtered_matches = [m for m in cap_matches if m.lower() not in question_words and m.lower() not in stop_words]
            
            if filtered_matches:
                result = ' '.join(filtered_matches)
                print(f"üîç T√©rmino extra√≠do (may√∫sculas filtradas): '{result}'")
                return result
        
        # ESTRATEGIA 3: Buscar despu√©s de palabras clave espec√≠ficas
        keywords_patterns = [
            r'(?:discos?|√°lbumes?|albums?)\s+(?:de\s+)?([a-zA-Z][a-zA-Z\s]+?)(?:\s+tengo|\s+teengo|\?|$)',
            r'(?:tengo|teengo)\s+(?:de\s+)?([a-zA-Z][a-zA-Z\s]+?)(?:\s+en|\?|$)',
        ]
        
        for pattern in keywords_patterns:
            match = re.search(pattern, query, re.IGNORECASE)
            if match:
                result = match.group(1).strip()
                # Limpiar stop words
                result = re.sub(r'\s+(de|en|mi|tu|la|el|los|las)$', '', result, flags=re.IGNORECASE)
                if result and len(result) > 2:
                    print(f"üîç T√©rmino extra√≠do (keywords): '{result}'")
                    return result
        
        # Limpiar la query de signos de puntuaci√≥n
        query_clean = re.sub(r'[¬ø?¬°!.,;:]', '', query.lower())
        
        # Dividir en palabras
        words = query_clean.split()
        
        # Filtrar stop words
        meaningful_words = [w for w in words if w not in stop_words and len(w) > 2]
        
        # Unir las palabras significativas
        result = ' '.join(meaningful_words)
        
        print(f"üîç T√©rmino extra√≠do (filtrado): '{result}'")
        return result if result else query
    
    async def close(self):
        """Cerrar todas las conexiones"""
        try:
            await self.navidrome.close()
            if self.lastfm:
                await self.lastfm.close()
            if self.listenbrainz:
                await self.listenbrainz.close()
        except Exception as e:
            print(f"Error cerrando conexiones: {e}")

